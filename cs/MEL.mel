source generateChannelMenu.mel;// source Progress Windowsource "cs/csProgBar.mel";// Publish all selected nodesglobal proc publishAllSelected(){	string $sel[] = `ls -sl`;	string $target = $sel[size($sel)-1];	stringArrayRemoveAtIndex (size($sel)-1) $sel;		if (`nodeType $target` == "dagContainer"){			int $i;			for ($each in $sel){					++$i;			int $interrupt = progWindow($i, size($sel));			if ($interrupt == 1){				break;			}						containerPublish -publishNode $each "" $target;			containerPublish -bindNode $each $each $target;    	}		    }		else {		print "No Asset selected";    }}// Delete all displayLayersglobal proc deleteAllDisplayLayers(){	string $renderLayers[] = `listConnections layerManager`;	stringArrayRemoveAtIndex (0, $renderLayers);		if (size($renderLayers) != 0){		delete $renderLayers;		    }}//Remove Display Overridesglobal proc removeDisplayOverrides(){	string $sel[] = `ls -dag -type "transform" -sl`;		deleteAllDisplayLayers();	for ($each in $sel){			if (`attributeQuery -node $each -exists "visibility"`){				setAttr ($each + ".overrideEnabled") 0;            }		}}//Make Non-Selectableglobal proc makeNonSelectable(){	string $sel[] = `ls -type "transform" -sl`;		removeDisplayOverrides();		for ($each in $sel){		if (`attributeQuery -node $each -exists "visibility"`){			setAttr ($each + ".overrideEnabled") 1;			setAttr ($each + ".overrideDisplayType") 2;		}	}}//Connect Lights//Make Objects Non Renderableglobal proc setRenderable(int $i){	string $sel[] = `ls -dag -type "shape" -sl`;		for ($each in $sel){		setAttr ($each + ".castsShadows") $i;		setAttr ($each + ".receiveShadows") $i;		setAttr ($each + ".motionBlur")$i;		setAttr ($each + ".motionBlur") $i;		setAttr ($each + ".motionBlur") $i;		setAttr ($each + ".primaryVisibility") $i;		setAttr ($each + ".smoothShading") $i;		setAttr ($each + ".visibleInReflections") $i;		setAttr ($each + ".visibleInRefractions") $i;		setAttr ($each + ".doubleSided") $i;		setAttr ($each + ".miTransparencyCast") $i;		setAttr ($each + ".miTransparencyReceive") $i;		setAttr ($each + ".miReflectionReceive") $i;		setAttr ($each + ".miRefractionReceive") $i;		setAttr ($each + ".miFinalGatherCast") $i;		setAttr ($each + ".miFinalGatherReceive") $i;		setAttr ($each + ".geometryAntialiasingOverride") $i;		setAttr ($each + ".shadingSamplesOverride") $i;    }}global proc connectLights(){    string $sel[] = `ls -sl -dag -type "light"`;	string $target = $sel[0];	stringArrayRemoveAtIndex 0 $sel;		if ( !`objExists ( $target +".decay" )` ){		addAttr -k true -dv 0 -min 0 -max 3 -at double -ln decay $target;		setAttr ($target + ".decay") (`getAttr ($target + ".decayRate")`);		connectAttr ( $target + ".decay") ( $target + ".decayRate");    }	    for ($each in $sel){					connectAttr ($target + ".decay") ($each + ".decayRate");	    connectAttr ($target + ".intensity") ($each + ".intensity");	    connectAttr ($target + ".color") ($each + ".color");		connectAttr ($target + ".shadowColor") ($each + ".shadowColor");	    connectAttr ($target + ".useDepthMapShadows") ($each + ".useDepthMapShadows");	    connectAttr ($target + ".dmapResolution") ($each + ".dmapResolution");	    connectAttr ($target + ".dmapFilterSize") ($each + ".dmapFilterSize");		connectAttr ($target + ".dmapBias") ($each + ".dmapBias");	    connectAttr ($target + ".useRayTraceShadows") ($each + ".useRayTraceShadows");	    connectAttr ($target + ".lightRadius") ($each + ".lightRadius");	    connectAttr ($target + ".shadowRays") ($each + ".shadowRays");		connectAttr ($target + ".rayDepthLimit") ($each + ".rayDepthLimit");		connectAttr ($target + ".emitDiffuse") ($each + ".emitDiffuse");		connectAttr ($target + ".emitSpecular") ($each + ".emitSpecular");    }		string $parent[] = `listRelatives -p $target`;	rename $parent[0] ($parent[0] + "_MASTER");	print "Complete";}// Add series of shapes togetherglobal proc addShapes(){	string $sel[] = `ls -sl`;	string $target = $sel[0];	string $shapes[] = `ls -sl -dag -lf`;		delete -ch $sel;	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $sel;		stringArrayRemoveAtIndex(0, $shapes);	stringArrayRemoveAtIndex(0, $sel);		int $n = `size($shapes)`;		int $i = 0;	for ($i = 0; $i < ($n); ++$i){		int $interrupt = progWindow($i, $n);		if ($interrupt == 1){			break;		}		select -r $target;		parent -add -shape ($shapes[$i]);	}		delete $sel;}// PolyMirrorglobal proc mirrorPoly(){	string $sel[] = `ls -sl`;	string $base = $sel[1];	string $shape = $sel[0];		string $nShape[] = `duplicate -name "newShape" $base`;	string $temp[] = `duplicate $base`;	string $blendName[] = `blendShape -name "tmpBlend" $shape $temp[0]`;	setAttr -l 0 ($temp[0] + ".scaleX");	setAttr ($temp[0] + ".scaleX") (-1);	string $grp = `group $temp[0] $nShape[0]`;	setAttr ($grp + ".s") 50 50 50;	select -r $nShape[0] $temp[0];	string $wrapName[] = `doWrapArgList "2" { "1","0","0.01" }`;	setAttr ($blendName[0] + "." + $shape) 1;	DeleteHistory;	setAttr ($grp + ".s") 1 1 1;	parent -w $nShape;	delete $grp;}//SnapItglobal proc snapToPivot(){	//Get Data	string $sel[] = `ls -sl`;	float $trA[] = `xform -q -ws -t $sel[1]`;	float $rpA[] = `xform -q -rp $sel[1]`;	float $rpB[] = `xform -q -rp $sel[0]`;		xform -ws -t ($trA[0] + $rpA[0] - $rpB[0]) ($trA[1] + $rpA[1] - $rpB[1]) ($trA[2] + $rpA[2] - $rpB[2]) $sel[0];}//Mirror Connect Two Objectglobal proc mirrorConnect(){	string $sel[] = `ls -sl`;		if (size($sel) != 2){		print "/n Not enough or too many objects selected./n";    }		else{		connectAttr ($sel[0] + ".ty") ($sel[1] + ".ty");		connectAttr ($sel[0] + ".tz") ($sel[1] + ".tz");		connectAttr ($sel[0] + ".rx") ($sel[1] + ".rx");		connectAttr ($sel[0] + ".rz") ($sel[1] + ".rz");		connectAttr ($sel[0] + ".s") ($sel[1] + ".s");				string $mirrorNode = `shadingNode -n "mirrorObjNode" -asUtility multiplyDivide`;		setAttr ($mirrorNode + ".input2X") -1;		setAttr ($mirrorNode + ".input2Y") -1;				connectAttr ($sel[0] + ".tx") ($mirrorNode + ".input1X");		connectAttr ($sel[0] + ".ry") ($mirrorNode + ".input1Y");		connectAttr ($mirrorNode + ".outputX") ($sel[1] + ".tx");		connectAttr ($mirrorNode + ".outputY") ($sel[1] + ".ry");				select -r $sel[0];    }}//Add Object To Latticeglobal proc addToLatt(){	string $sel[] = `ls -sl`;	string $lattice = $sel[(size($sel)-1)];	stringArrayRemoveAtIndex((size($sel)-1), $sel);		for ($each in $sel){		lattice -e -g $each $lattice;    }}//Rivetglobal proc string rivet ( ){	//  Description:	//	Use "Rivet" to constrain locator to polygon or NURBS surfaces	//	Select two edges on polygon object	//	or select one point on NURBS surface and call rivet	//	Parent your rivets and buttons to this locator	string $nameObject;	string $namePOSI;		string $parts[];	string $list[] = `filterExpand -sm 32`;	int $size = size($list);		if ($size > 0){			if ($size != 2){			error("No two edges selected");			return "";		}		tokenize($list[0],".",$parts);		$nameObject = $parts[0];		tokenize($list[0],"[]",$parts);		float $e1 = $parts[1];		tokenize($list[1],"[]",$parts);		float $e2 = $parts[1];			string $nameCFME1 = `createNode curveFromMeshEdge -n "rivetCurveFromMeshEdge1"`;			setAttr ".ihi" 1;			setAttr ".ei[0]"  $e1;		string $nameCFME2 = `createNode curveFromMeshEdge -n "rivetCurveFromMeshEdge2"`;			setAttr ".ihi" 1;			setAttr ".ei[0]"  $e2;		string $nameLoft = `createNode loft -n "rivetLoft1"`;			setAttr -s 2 ".ic";			setAttr ".u" yes;			setAttr ".rsn" yes;			$namePOSI = `createNode pointOnSurfaceInfo -n "rivetPointOnSurfaceInfo1"`;			setAttr ".turnOnPercentage" 1;			setAttr ".parameterU" 0.5;			setAttr ".parameterV" 0.5;			connectAttr -f ($nameLoft + ".os") ($namePOSI + ".is");		connectAttr ($nameCFME1 + ".oc") ($nameLoft + ".ic[0]");		connectAttr ($nameCFME2 + ".oc") ($nameLoft + ".ic[1]");		connectAttr ($nameObject + ".w") ($nameCFME1 + ".im");		connectAttr ($nameObject + ".w") ($nameCFME2 + ".im");	}		else{		$list = `filterExpand -sm 41`;		$size = size($list);		if ($size > 0){					if ($size != 1){				error("No one point selected");				return "";			}						tokenize($list[0],".",$parts);			$nameObject = $parts[0];			tokenize($list[0],"[]",$parts);			float $u = $parts[1];			float $v = $parts[2];			$namePOSI = `createNode pointOnSurfaceInfo -n "rivetPointOnSurfaceInfo1"`;					setAttr ".turnOnPercentage" 0;					setAttr ".parameterU" $u;					setAttr ".parameterV" $v;			connectAttr -f ($nameObject + ".ws") ($namePOSI + ".is");		}				else{			error("No edges or point selected");			return "";		}	}	string $nameLocator = `createNode transform -n "rivet1"`;	createNode locator -n ($nameLocator + "Shape") -p $nameLocator;		string $nameAC = `createNode aimConstraint -p $nameLocator -n ($nameLocator + "_rivetAimConstraint1")`;		setAttr ".tg[0].tw" 1;		setAttr ".a" -type "double3" 0 1 0;		setAttr ".u" -type "double3" 0 0 1;		setAttr -k off ".v";		setAttr -k off ".tx";		setAttr -k off ".ty";		setAttr -k off ".tz";		setAttr -k off ".rx";		setAttr -k off ".ry";		setAttr -k off ".rz";		setAttr -k off ".sx";		setAttr -k off ".sy";		setAttr -k off ".sz";		connectAttr ($namePOSI + ".position") ($nameLocator + ".translate");	connectAttr ($namePOSI + ".n") ($nameAC + ".tg[0].tt");	connectAttr ($namePOSI + ".tv") ($nameAC + ".wu");	connectAttr ($nameAC + ".crx") ($nameLocator + ".rx");	connectAttr ($nameAC + ".cry") ($nameLocator + ".ry");	connectAttr ($nameAC + ".crz") ($nameLocator + ".rz");		select -r $nameLocator;	return ($nameLocator);}//Combine Polygonsglobal proc combinePoly(){	//Get Data	string $sel[] = `ls -sl`;		//Combine Objects	string $new[] = `polyUnite -ch 0 $sel`;		//Cleanup	polyMergeVertex  -d 0.001 -ch 0 $new[0];	makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $new[0];	delete -ch $new[0];		string $newObj = `rename $new[0] $sel[0]`;	select -r $newObj;}//Mirror an Instanced Copyglobal proc mirrorInst(){	string $sel[] = `ls -sl`;		for ($each in $sel){			delete -ch $each;		makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $each;		move 0 0 0 ($each + ".scalePivot") ($each + ".rotatePivot");		instance $each;				// Mirror Selected Object		setAttr ($each + ".scaleX") -1;    }}//create a blend-Shape Clone of the current selectionglobal proc createBlendClone(){	string $sel[] = `ls -sl`;	string $targets[];		if ((size($sel)) == 1){		$targets = `listRelatives $sel`;    }else{		$targets = $sel;    }		string $shapes[];		for ($each in $targets){		string $new[] = `duplicate -n ("bs_" + $each) $each`;		$shapes[size($shapes)] = $new[0];		string $newBlend[] = `blendShape -w -n ("BS" + $each) $new[0] $each`;		setAttr ($newBlend[0] + "." + $new[0]) 1;    }		string $shapesGrp = `group -n ($sel[0] + "Shapes") $shapes`;	select -r $shapesGrp;}// use current selection as blend-shapesglobal proc makeBlendShapeFrom(){	string $sel[] = `ls -sl`;	string $mesh[];		if (size($sel) == 1){		$mesh = `listRelatives $sel`;    }else{		$mesh = $sel;    }		string $shapes[];		for ($each in $mesh){		string $dup[] = `duplicate -n ($each + "New") $each`;		$shapes[size($shapes)] = $dup[0];		string $blendShape[] = `blendShape -n ("bs_" + $each) $each $dup[0]`;		setAttr ($blendShape[0] + "." + $each) 1;    }		string $newGrp = `group -n "newShapes" $shapes`;	select -r $newGrp;}//Add Joints to Skinned objectglobal proc AddSkinned(){	string $sel[] = `ls -sl`;	int $selsize = `size($sel)`;	string $base = $sel[($selsize-1)];		for ($i=0; $i < ($selsize-1); $i++){		select -r $base $sel[$i];		skinClusterInfluence 1 " -dr 4 -lw true -wt 0";		setAttr ($sel[$i] + ".lockInfluenceWeights") 0;	}		select -cl;}//Pose2Shelfglobal proc string saveSelectedNodeAttrsToShelf(string $label){	string $selected[] = `ls -sl`;		if ( !`size($selected)` ){		warning "Pete Says: Nothing selected. No shelf button created.";		return "Pete Says: Nothing selected. No shelf button created.";		}		string $safeShelfCommand;		for ($node in $selected){		string $keyableAttrs[] = `listAttr -r -w -k -u -v -m -s $node`;		if ( !`size($keyableAttrs)`){			continue;			} 		for ($attr in $keyableAttrs)		{			string $value = string ( `getAttr ($node+"."+$attr)` );			$safeShelfCommand = ("catch (`setAttr \""+$node +"."+$attr+"\" "+$value+"`);\n")+$safeShelfCommand;		}	}	global string $gShelfTopLevel;		if (`tabLayout -exists $gShelfTopLevel`){		print "\n\n\n";			print "// Set Attribute commands put into shelf: \n\n";		print $safeShelfCommand;		print "\n";				if ($label == ""){			$label = "pose.";		}				shelfButton			-parent ($gShelfTopLevel + "|" + `tabLayout -q -st $gShelfTopLevel`)			-enableCommandRepeat 1			-enable 1			-width 34			-height 34			-manage 1			-visible 1			-annotation $label			-label $label 			-iol $label			-image1 "menuIconCharacters.xpm" 			-style "iconOnly" 			-command $safeShelfCommand;	}		else{		error "Pete says: SHOW YOUR SHELF!";	}		return $safeShelfCommand;}global proc string saveNodeSelectionToShelf(string $label){	string $selected[] = `ls -sl`;		if ( !`size($selected)` ){		warning "Pete Says: Nothing selected. No shelf button created.";		return "Pete Says: Nothing selected. No shelf button created.";		}		string $safeShelfCommand;		for ($node in $selected){		$safeShelfCommand = ("catch (`select -add \""+$node+"\"`);\n")+$safeShelfCommand;	}		$safeShelfCommand = "select -cl;\n"+$safeShelfCommand;	global string $gShelfTopLevel;		if (`tabLayout -exists $gShelfTopLevel`){			print "\n\n\n";			print "// Selection commands put into shelf: \n\n";		print $safeShelfCommand;		print "\n";				if ($label == ""){			$label = "select.";		}				shelfButton			-parent ($gShelfTopLevel + "|" + `tabLayout -q -st $gShelfTopLevel`)			-enableCommandRepeat 1			-enable 1			-width 34			-height 34			-manage 1			-visible 1			-annotation $label			-label $label 			-iol $label			-image1 "aselect.xpm" 			-style "iconOnly" 			-command $safeShelfCommand;	}		else{		error "Pete Says: SHOW YOUR SHELF!";	}		return $safeShelfCommand;}//Random Move/Rotate/Scaleglobal proc randMove(){	string $sel[] = `ls -sl`;		for ($each in $sel){   		move -r (rand(-1, 1)) (rand(-1, 1)) (rand(-1, 1)) $each;	}}global proc randRot(){	string $sel[] = `ls -sl`;		for ($each in $sel){   		rotate -r (rand(-20, 20)) (rand(-20, 20)) (rand(-20, 20)) $each;	}}// Menuglobal proc Mel_Menu(){	source generateChannelMenu.mel;  	if(`window -q -ex mel_Menu`){  		deleteUI mel_Menu;	}	    window		-w 200		-h 780		-rtf 1		-mnb 0		-mxb 0		-s 0		-title "Pete's Mel Scripts"		mel_Menu;	    columnLayout ColumnLayout;	button		-bgc 0 1 0		-w 190		-l "Publish All Selected"		-ann "Select the Nodes, and then ctrl/shift select the Asset"		-c "publishAllSelected()";	button		-bgc 0 1 0		-w 190		-l "Remove Any Display Overrides"		-ann "Select the Nodes you wish to clear display Overrides for"		-c "removeDisplayOverrides()";	button		-bgc 0 1 0		-w 190		-l "Make Selected Non-Selectable"		-ann "Select the Nodes you wish to make non-selectable"		-c "makeNonSelectable()";	button		-bgc 0 1 0		-w 190		-l "Make Objects Non-Renderable"		-ann "Select the objects you wish to make non-renderable"		-c "setRenderable(0)";	text -label "";	button		-bgc 0 1 0		-w 190		-l "snapToPivot"		-ann "SnapToObject's Pivot Point"		-c "snapToPivot()";	button		-bgc 0 1 0		-w 190		-l "MirrorConnect"		-ann "Mirror the location of an Object to a second Object"		-c "mirrorConnect()";	text -label "";	button		-bgc 0 1 0		-w 190		-l "Random Move"		-ann "Move all objects a random amount"		-c "randMove()";	button		-bgc 0 1 0		-w 190		-l "Random Rotate"		-ann "Rotate all objects a random amount"		-c "randRot()";	text -l "";    button		-bgc 0 1 0		-w 190		-label "Mirror Instanced"		-ann "Mirror Instanced"		-c "mirrorInst()";	button		-bgc 0 1 0		-w 190		-label "Mirror Poly for BlendShape"		-ann "Mirror's a polygon shape in the -X axix. Use to mirror Blend Shapes"		-c "mirrorPoly()";	button		-bgc 0 1 0		-w 190		-label "Create BlendShape Clone"		-ann "Select the geometry to clone"		-c "createBlendClone()";	button		-bgc 0 1 0		-w 190		-label "Use Selection as Blendshapes"		-ann "Select the geometry you wish to influence new shapes"		-c "makeBlendShapeFrom()";	text -l "";    button		-bgc 0 1 0		-w 190		-label "Combine Mesh Objects"		-ann "Select all objects you wish to combine"		-c "combinePoly()";	button		-bgc 0 1 0		-w 190		-l "Combine Curve Shapes"		-ann "select curve, and then shapes to be added"		-c "addShapes()";		text -l "";	button		-bgc 0 1 0		-w 190		-label "Add Objects to Lattice"		-ann "Select objects and then the lattice to add them too"		-c "addToLatt()";	button		-bgc 0 1 0		-w 190		-label "Add Joint to Skinned Objects"		-ann "Add Joint to Skinned Objects"		-c "AddSkinned()";	button		-bgc 0 1 0		-w 190		-l "Connect Multiple Lights"		-ann "select all the lights you want to connect, the first in the selection will become the master"		-c "connectLights()";	text -l "";	button		-bgc 0 1 0		-w 190		-l "Rivet"		-ann "Select 2 edges of Poly Surface to Create Pin Locator"		-c "rivet()";	text -l "";	text -w 190 -l "Pose2Shelf:";	textField		-w 190		"_custButtonWin";	button		-bgc 1 1 0		-h 35		-w 190		-ann "Save Selected Node's \"setAttr\" Commands to a Shelf Button."		-label "Pose2Shelf"		-c ("saveSelectedNodeAttrsToShelf( `textField -q -tx _custButtonWin` );");	button		-bgc 1 1 0		-w 190		-ann "Save Current Selection's Selection Commands as a Shelf Button."		-label "Selection2Shelf"		-c ("saveNodeSelectionToShelf( `textField -q -tx _custButtonWin` );");	text -l "";	button		-bgc 0 1 1		-w 190		-l "Dynamic Link Chain"		-ann "Load Dynamic Link Chain Menu"		-c "source DynamicLinkChain.mel";	button		-bgc 0 1 1		-w 190		-l "Advanced Rename"		-ann "Advanced Object Rename"		-c "source advancedRename.mel";	button		-bgc 0 1 1		-w 190		-l "Ninja Light"		-ann "Ninja Light"		-c "Ninja_Light.mel";	button		-bgc 0 1 1		-w 190		-l "ROG"		-ann "Repeating Object Generator"		-c "source ROG.mel";    showWindow mel_Menu;	window -e -w 200 -h 780 mel_Menu;}// Launch MenuMel_Menu();